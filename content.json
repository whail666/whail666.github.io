[{"title":"王海龙","date":"2021-07-04T11:46:57.000Z","path":"2021/07/04/王海龙/","text":"","link":"","tags":[]},{"title":"AAABBBB博客","date":"2021-07-04T01:55:08.000Z","path":"2021/07/03/AAABBBB博客/","text":"linux固定USB口名字12345678# On precise, for some reason, USER and GROUP are getting ignored.# So setting mode = 0666 for now.# udevadm info --attribute-walk --name=/dev/ttyUSBX &quot;CAT KERNELS&quot; ##KERNEL==&quot;ttyUSB*&quot;, PROGRAM==&quot;/etc/udev/rules.d/66-lzy-tty.py&quot;// etc/udev/rules.d#KERNELS==&quot;1-12:1.0&quot;, MODE:=&quot;0666&quot;, GROUP:=&quot;dialout&quot;, SYMLINK+=&quot;USB_0&quot;sudo adduser nvidia dialout 树莓派开机自启动18.041234Unity桌面环境在Unity Dash中键入&quot;startup&quot;（启动）Linux桌面环境下自动启动程序？https://blog.csdn.net/weixin_30824277/article/details/96814775 https://blog.csdn.net/qq_25711251/article/details/80385069?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs 测试正常 ：https://www.cnblogs.com/dhcn/p/11523914.html 1、rcS.添加 2、https://blog.csdn.net/weixin_44823747/article/details/109010756 3、setstart添加 lsb_release -a //查看虚拟机版本uname -a //查看虚拟机位数，但是没有下一个命令直观getconf LONG_BIT//查看long的位数，可以直接反映出虚拟机位数 复制SD卡https://blog.csdn.net/zhenguo26/article/details/79967247?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control 复制SD卡；写入SD卡 问题： 写入SD卡失败 检查读卡器、电源 无法启动boot 5、树莓派用户名密码：ubuntu 和 xuebaogaoke wifi:DHCP 密码：12345678 mavros自定义message id路径：mavros_ws/src/mavlink/message_definitions/v1.0/common.xml 12345678910&lt;message id=&quot;13002&quot; name=&quot;MULTIPLE_TARGET&quot;&gt; &lt;description&gt;save airpalne number and mutli TARGET point &lt;/description&gt; &lt;field type=&quot;uint8_t&quot; name=&quot;flag&quot;&gt;number control flag &lt;/field&gt; &lt;field type=&quot;uint8_t&quot; name=&quot;target_number&quot;&gt;all the target number&lt;/field&gt; &lt;field type=&quot;uint16_t&quot; name=&quot;airpalne_number&quot;&gt;all the airpalne number&lt;/field&gt; &lt;field type=&quot;uint16_t&quot; name=&quot;reserve&quot;&gt; reserve space &lt;/field&gt; &lt;field type=&quot;float[10]&quot; name=&quot;lat&quot;&gt; the latitude &lt;/field&gt; &lt;field type=&quot;float[10]&quot; name=&quot;lon&quot;&gt; the longitude &lt;/field&gt; &lt;field type=&quot;float[10]&quot; name=&quot;alt&quot;&gt; the altitude default null&lt;/field&gt;&lt;/message&gt; 路径：/mavros_ws/src/mavros/mavros_msgs/msg 123456789101112# raw servo values for direct actuator controls## about multiple target position# https://pixhawk.org/dev/mixinguint8 Flaguint8 NumberTargetuint16 NumberAirplaneuint16 Reservefloat32[10] latfloat32[10] lonfloat32[10] alt 路径/home/book/mavros_ws/src/mavros/mavros_msgs/CMakeLists.txt add_message_files（ … MultipleTargetPoint.msg ） 路径：/home/book/mavros_ws/src/mavros/mavros_extras/src/plugins 添加文件 multiple_position.cpp 添加CmakeList： src/plugins/multiple_position.cpp 文件/mavros_ws/src/mavros/mavros_extras/mavrosplugins.xml 12添加&lt;class name=&quot;multiple_position&quot; type=&quot;mavros::extra_plugins::multiple_positionPlugin&quot; base_class_type=&quot;mavros::plugin::PluginBase&quot;&gt; 蜂群算法引力 12/*target吸引力：+20*(1-exp(-dist/100))//初始化，设定delta_x,delta_y为目标坐标与飞机当前位置差，如果有邻居飞机，则调整*/delta_xy= 20*(1-exp(-dist2target/100))*( matrix::Vector2f(target_local_position) - self_local_position)/dist2target * delta_xy_parameter; 一字编队12345判断在当前位置的左侧还是右侧：已知坐标：目标点、当前飞机、附近飞机向量1：当前飞机-目标点向量2：当前飞机-附近飞机求： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123close allclear%% initializationdrone_num=30;x0=500*(rand(drone_num,1)-0.5);y0=500*(rand(drone_num,1)-0.5);drone_positions=[x0 y0];drone_positions_err=drone_positions+2*randn(size(drone_positions)); %2meter errordrone_velocities=[10*(rand(drone_num,1)-0.5) 50*ones(drone_num,1)+20*(rand(drone_num,1)-0.5)];target_num=10; %目标点的个数target=[ 800*(rand(target_num,1)-0.5) 1000*(rand(target_num,1)-0.5)+5000 ]; %目标点位置% target=[-50 80;-0 100;50 80;];drone_target_counter=zeros(target_num,1);detection_range_radius=60;nsteps=200;keff=0.4;delta_t=1;uniform_space=50;delta_Yposition_lasttime=zeros(drone_num,1);%%figurepause(1)for istep=1:nsteps% if istep&gt;50% drone_positions_err(15:29,:)=inf;% end for i=1:drone_num sumVy=0; sumPy=0; nneighbor=0; % 运动方向上的速度计算 for j=1:drone_num if j~=i dd=sqrt((drone_positions_err(j,1)-drone_positions_err(i,1))^2+(drone_positions_err(j,2)-drone_positions_err(i,2))^2); if dd&lt;500 sumPy=sumPy+drone_positions_err(j,2); nneighbor=nneighbor+1; end end for i_target=1:target_num %根据目标序号循环 drone_positions2target=sqrt((target(i_target,1)-drone_positions_err(i,1))^2+(target(i_target,2)-drone_positions_err(i,2))^2); if drone_positions2target&lt;=detection_range_radius drone_positions_err(i,2)=target(j,2); drone_positions_err(i,1)=target(j,1); target_hit(i,2)=target(j,2); target_hit(i,1)=target(j,1); drone_positions_hit(i,1)=drone_positions_err(i,1); drone_positions_hit(i,2)=drone_positions_err(i,2); plot_flag=1; drone_positions_err(i,1)=inf; drone_positions_err(i,2)=inf; end end end if nneighbor&gt;0 delta_Yposition_currenttime=drone_positions_err(i,2)-sumPy/nneighbor; drone_velocities(i,2)=drone_velocities(i,2)-keff*(delta_Yposition_currenttime-delta_Yposition_lasttime(i)); delta_Yposition_lasttime(i)=delta_Yposition_currenttime; end % 垂直于运动方向上（一字）的速度计算 dd=sqrt((drone_positions_err(:,1)-drone_positions_err(i,1)).^2+(drone_positions_err(:,2)-drone_positions_err(i,2)).^2); dd_minus=dd(dd&lt;500 &amp; drone_positions_err(:,1)&lt;drone_positions_err(i,1)); dd_plus=dd(dd&lt;500 &amp; drone_positions_err(:,1)&gt;drone_positions_err(i,1)); density_minus=0; density_plus=0; if ~isempty(dd_minus) density_minus=max(dd_minus)/length(dd_minus); end if ~isempty(dd_plus) density_plus=max(dd_plus)/length(dd_plus); end if density_minus==0 drone_velocities(i,1)=keff*(density_plus-50); elseif density_plus==0 drone_velocities(i,1)=-keff*(density_minus-50); else drone_velocities(i,1)=keff*(density_plus-density_minus); end end for i=1:drone_num drone_positions_err(i,1)=drone_positions_err(i,1)+drone_velocities(i,1)*delta_t+2*rand; %2meter error drone_positions_err(i,2)=drone_positions_err(i,2)+drone_velocities(i,2)*delta_t+2*rand; %2meter error end plot(x0,y0,&#x27;kx&#x27;) hold on;grid on;box on; plot(x0,y0,&#x27;kx&#x27;) hold on;grid on;box on; for i=1:target_num plot(target(i,1),target(i,2),&#x27;bo&#x27;,&#x27;MarkerFaceColor&#x27;,&#x27;b&#x27;) %%目标点显示 end plot(drone_positions_err(:,1),drone_positions_err(:,2),&#x27;r+&#x27;) axis([-1000 1000 -300 7000]) title(num2str(istep)) xlabel(&#x27;米&#x27;) ylabel(&#x27;米&#x27;) hold off; pause(0.01)end linux命令查看有无安装opencv1234pkg-config：https://blog.csdn.net/qq_38455499/article/details/108361652 jetson-nano 安装方法下载SDK Manager 12https://developer.nvidia.com/zh-cn/embedded/downloads#?search=sdk%20manager注册登录（注册时需要到官方网站填写详细信息进行验证） 打开sdkmanager选择下载需要的组件与系统并选择路径 连接硬件 12345将jetson_nano板处于引导模式，1、将rec与gnd连接2、给开发板通电几秒3、断开rec与gnd的连接静等即可，系统会在nano板子中安装成功。 查看下载的软件 将板子的系统打包成新的镜像 进入到路径./jetson-disk-image-creator.sh -o sd-blob.img -b jetson-nano -r 300 生成镜像 将镜像烧录到sd卡中 sudo dd if=sd-blob.img of=/dev/sdb bs=1M oflag=direct 建议使用balenaEtcher-1.5.115-x64.AppImage 软件下载（在下载的组件中，双击解压JetPack_4.4_Linux_JETSON_NANO_DEVKIT 或者 网上下载） 手动生成镜像 需要进入root权限 12# sudo su# ./jetson-disk-image-creator.sh -o sd-blob.img -b jetson-nano -r 300 镜像路径： 系统拷贝 把已有的系统里面的文件，全部替换到Linux_for_Tegra / rootfs 里面,再执行镜像生成脚本命令，会在tools下生成.img的镜像 SD卡格式化 取消U盘挂载 1linux: umount /media/book/e286d650-ab10-406b-ac5c-ad680413cc6a 卸载分区 123fdisk -m /dev/sdc //根据自己的sd卡选择sd*，确认sd*可以通过插入时间确认 //-m 显示所有功能 //-d 选择删除分区 格式化磁盘 1mkfs.ext3 /dev/sdc //格式化/dev/sdc的sd卡为ext3格式 SD卡分区 烧录的系统是sdda*，为什么会有这么分区呢 查看分区 SD卡需要free space（sdb），不然无法存储文件 ![](.\\image\\nano_SD卡（有free space）.jpg) ![](.\\image\\fdisk 格式化后的windows格式.jpg) cmake如何生成和使用三方库1234567891011https://blog.csdn.net/robinhjwy/article/details/78856454https://blog.csdn.net/alan711/article/details/86248612CMake的配置信息写在了CMakeList.txt文件中。在CMakeList.txt文件里，我们首先定义两个变量INC_DIR和LINK_DIR，用来表示头文件路径和库的路径。这里以我放在Downloads文件下的wfdb库为例，代码如下：set(INC_DIR /Users/haoran/Downloads/wfdb/include)set(LINK_DIR /Users/haoran/Downloads/wfdb/lib)查找库pkg linux配置基本命令123echo $PATH #用于打印哪些可执行的程序的路径比如：ls cd ...export PATH=$PATH:/usr/locar/new/bin #添加这个命令source #:环境变量 SD卡分区表1 翻墙代理1 如何快速查看介入的串口/usb 对应设备名字1 查看系统log1 脚本 12345678910111213linux脚本 source: not found在Ubuntu 当中 执行脚本默认的使用的是dash，而非bash，执行能力较弱，例如1.sh#!/bin/shsource /etc/profile 输出：source: not found2.sh#!/bin/bashsource /etc/profile 正常执行3.source等价于 . mavros-固定翼1234567891011121314151617//起飞book@100ask:~$ rostopic pub -r 10 /mavros/setpoint_raw/local mavros_msgs/PositionTarget &quot;header: seq: 0 stamp: &#123;secs: 0, nsecs: 0&#125; frame_id: &#x27;&#x27;coordinate_frame: 0type_mask: 4096position: &#123;x: 0.0, y: 1000.0, z: 50.0&#125;velocity: &#123;x: 0.0, y: 0.0, z: 0.0&#125;acceleration_or_force: &#123;x: 0.0, y: 0.0, z: 0.0&#125;yaw: 0.0yaw_rate: 0.0&quot;//rosservice call /mavros/set_mode &quot;base_mode: 0custom_mode: &#x27;offboard&#x27;&quot;注意：固定翼：速度越快，高度就越高 px4的硬件在环仿真步骤参考官方：https://dev.px4.io/en/simulation/hitl.html https://ardupilot.org/dev/docs/sitl-simulator-software-in-the-loop.html 12345678硬件在环仿真 ：Hardware in the Loop Simulation (HITL / HIL)硬件仿真 ：Simulation-In-Hardware (SIH)循环软件 ：Software in the Loop(SITL)硬件在环仿真可以在普通硬件上运行px4固件，仿真真实的测试情况原理：使用Tools下的工具将px4与QGroundControl进行连接，同时QGroundControl会提供gps等数据。区别：SITL（循环软件）模拟器允许您在没有任何硬件的情况下运行飞机、直升机或漫游者。它是使用普通 C++ 编译器构建的自动驾驶仪代码，为您提供本机可执行文件，允许您在没有硬件的情况下测试代码的行为。硬件在环（HITL 或 HIL）是一种模拟模式，在这种模式下，普通 PX4 固件运行在真实的飞控硬件上。这种方法的好处是可以在真实硬件上测试大部分实际飞行代码。 验证测试HITL 准备 1QGroundControl 一架px4飞机。 配置QGroundControl： 将px4飞控链接QGroundControl 启用HITL模式 ```bash 打开QGroundControl-&gt;设置-&gt;安全 将HITL Enabled改为Enabled123456789101112131415161718192021222324252627282930313. 选择机身 1. 打开QGroundControl-&gt;设置-&gt;机身 2. ![](.\\image\\qgc_仿真.png)4. 设置UDP 1. ![](.\\image\\qgc仿真hitl.png) 2. （可选）配置操纵杆和故障安全 1. [COM_RC_IN_MODE](http://docs.px4.io/master/en/advanced_config/parameter_reference.html#COM_RC_IN_MODE)到“操纵杆/无 RC 检查”。这允许操纵杆输入并禁用 RC 输入检查。 2. [NAV_RCL_ACT](http://docs.px4.io/master/en/advanced_config/parameter_reference.html#NAV_RCL_ACT)为“禁用”。这可确保在不使用无线电控制运行 HITL 时不会受到 RC 故障保护操作的干扰。 完成，关闭QGroundControl，断开硬件 重启后，可以直接在QGroundControl中看到飞机，同时使用真实遥控器控制飞机。 **开始模拟** https://docs.px4.io/master/en/simulation/multi_vehicle_simulation_gazebo.html**测试验证硬件仿真（SIH）**https://docs.px4.io/master/en/simulation/simulation-in-hardware.html**验证测试SITL** 使用模拟器模拟飞机，gazebo+ROS一起使用1234567891011121314151617**准备**```bash#https://docs.px4.io/master/en/simulation/multi_vehicle_simulation_gazebo.html，含有ROS版本的Gazebo仿真#下载源码PX4 PX4-Autopilot#进入源码配置cd Firmware_clonegit submodule update --init --recursiveDONT_RUN=1 make px4_sitl_default gazebo#配置环境变量source Tools/setup_gazebo.bash $(pwd) $(pwd)/build/px4_sitl_defaultexport ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:$(pwd):$(pwd)/Tools/sitl_gazebo#启动launch文件roslaunch multi_uav_mavros_sitl.launch/PX4-Autopilot/launch$ roslaunch multi_uav_mavros_sitl.launch 12安装mavros 可以根据launch文件查看功能， ROS::launch文件123456789101112131415161718#启动节点的launch文件&lt;launch&gt; &lt;include file=&quot;$(find mavros)/launch/px4.launch&quot; /&gt; &lt;param name =&quot;string_var&quot; type=&quot;double&quot; value =&quot;10.4&quot; /&gt; &lt;node name=&quot;test_main1&quot; pkg =&quot;wang_pkg&quot; type=&quot;wang_pkg_node&quot; output=&quot;screen&quot;&gt; &lt;/node&gt;&lt;/launch&gt;说明：node name=&quot;test_main1&quot;： 是test_src.cpp ros::init(argc,argv,&quot;test_main1&quot;);pkg = &quot;wang_pkg&quot; 是ros_test_log_ws/src$ rospack depends1 wang_pkg type = &quot;wang_pkg_node&quot; 是CMakeLists.txt add_executable($&#123;PROJECT_NAME&#125;_node src/test_src.cpp)output = &quot;screen&quot; 是screen或者log注意：rosnode list ：命令显示的是node name后面的名字，因此可以复制&lt;node &gt;&lt;/node&gt;只修改name，实现节点多用在cpp文件中获取param值需要将节点名为（&quot;~&quot;） 1 launch命令 1http://wiki.ros.org/cn/roslaunch/Commandline%20Tools launch文件 1 ROS存储log1231、节点需要使用launch文件启动2、存储路径~/.ros/log 3、只会存储最近的一次数据，再次启动会覆盖 标准log输出1 ROS的系统开机启动1234567891011https://zhuanlan.zhihu.com/p/163048849https://www.guyuehome.com/18734https://www.pianshen.com/article/1254309062/rosrun robot_upstart install myrobot_bringup/launch/base.launch$ sudo service myrobot start$ sudo service myrobot stop查看log$ sudo tail /var/log/upstart/myrobot.log -n 30删除rosrun robot_upstart unstall myrobot linux的系统开机启动12* service 代码审核工具（声呐SonarQube）1 C++ 不实例化类对象，直接调用类成员函数方法 12345678910#include &lt;iostream&gt;using namespace std;class A &#123;public: void print() &#123; cout&lt;&lt;&quot;123&quot;; &#125;&#125;;int main()&#123; (*(A*)nullptr).print();&#125; thread和pthread 1234567多线程编程中会用到两个头文件，thread和pthread。pthread早于thread出现，本来是在类POSIX系统中用来多线程编程的，Windows原生不支持。C++11之后， 只要Windows、Linux支持C++11都可以使用原生的thread头文件, 这是C++标准委员会支持的原生语法。 尽管thread可以用来进行跨平台的多线程编程，但是thread跟pthread有诸多不同。 thread是C++的API, 不可以在C++中调用，换句话说，它更加简单和安全。 它大量使用RAII来确保资源在超出范围时得到回收，并允许您从函数对象创建一个线程，具有所有的灵活性，而不是被限制为C风格的自由函数。 pthread是一个C的API，因此它不提供任何RAII，这使得它更难使用，更容易出错，特别是就异常安全性而言（除非你自己编写了包装，你现在必须调试 并保持）。所谓RAII是 Resource Acquisition Is Initialization 的简称，是C++语言的一种管理资源、避免泄漏的惯用法，利用的是C++构造的对象最终会被销毁的原则。 C++11多线程 123std::thread th1(&amp;FlightTask::uwb_trasmit_pthread,this);//th1.join(); //阻塞th1.detach();//非阻塞 C++11lambda表达式 C++11的lambda表达式 http://c.biancheng.net/view/433.html 123456789101112131415int a=55；[=] (int x, int y) -&gt; bool &#123;&#125;=:在 &#123;&#125;中不允许修改外部变量的值a的值不允许改动&amp;:在 &#123;&#125;中允许修改外部变量的值，a的值允许改动注意：先中括号[] 再小括号（）//打印v向量for_each(v.begin(),v.end(),[](int data)&#123;cout&lt;&lt;data&lt;&lt;endl;&#125;)当使用map时候，属性是pair for_each(m.begin(),m.end(),[=]( std::pair&lt;const int,int&gt; a)&#123; cout&lt;&lt;&quot;a.begin\\n&quot;&lt;&lt;a.first &lt;&lt;endl; &#125;); Eigen 矩阵库 MakefileCmake vscode 什么是插件 1插件：更便捷的使用相关的工具，但是不影响工具，比如c++11，插件会提供补全、关键字颜色等，但是不会影响c++11 安装基本软件 12345//需要安装vscode软件//编译c++需要安装gcc、gdb gcc -v sudo apt-get update sudo apt-get install build-essential gdb 创建工程 12345mkdir projectscd projectsmkdir helloworldcd helloworldcode . 1234//打开后会在当前目录下自动创建.vscode文件，需要手动/自动创建如下三个文件： tasks.json （编译器构建设置，直接运行程序：终端-&gt;配置默认构建任务） launch.json （调试器设置，自动生成） c_cpp_properties.json （编译器路径和 IntelliSense 设置，自动生成） 安装c++插件终端” &gt;“配置默认构建任务如下是详细介绍 运行 helloworld.cpp程序 1234561、编写helloworld.cpp程序2、同级目录下创建 .vscode文件夹3、选择”终端” &gt;“配置默认构建任务”，选择使用哪个c++编译器，会自动创建tasks.json文件；（也可以手动在.vscode中手动创建tasks.json）4、选中helloworld.cpp程序，处于活动界面5、选择”终端” &gt;“运行生成任务”6、在当前目录下生成执行文件helloworld tasks.json的主要功能介绍 12 您可以tasks.json通过使用类似的参数&quot;$&#123;workspaceFolder&#125;/*.cpp&quot;而不是$&#123;file&#125;. 您还可以通过替换&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;为硬编码文件名（例如“helloworld.out”）来修改输出文件名 调试 helloworld.cpp 1231、运行 Run &gt; Add Configuration...，然后选择C++ (GDB/LLDB),会自动在.vscode下创建一个launch.json文件和tasks.json文件2、将*.cpp处于活动窗口3、运行 运行&gt;启动调试 c/c++配置 12如果您想要更多地控制 C/C++ 扩展，在.vscode下创建c_cpp_properties.json文件，该文件更改设置，例如编译器路径、包含路径、C++ 标准（默认为 C++17）等。可以通过从命令面板 ( Ctrl+Shift+P )运行命令C/C++: Edit Configurations (UI)来查看 C/C++ 配置 UI，自动生成文件c_cpp_properties.json Cmake 1234安装插件cmakeCtrl+Shift+P ) 并运行CMake: Quick Start命令：输入项目名称 选择Executable作为项目类型以创建main.cpp包含基本main()功能的基本源文件 ( ) 这将创建一个 hello world CMake 项目main.cpp，CMakeLists.txt其中包含, （告诉 CMake 工具如何构建您的项目），以及一个以build您的构建文件命名的文件夹： 选择使用哪个编译器 1打开命令面板 ( Ctrl+Shift+P ) 并运行CMake: Select a Kit。","link":"","tags":[]},{"title":"Hello World","date":"2021-07-04T01:51:35.329Z","path":"2021/07/03/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"","tags":[]}]